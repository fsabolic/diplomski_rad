<!--SOURCE: https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title></title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />
    <script src="definirajPiramidu copy.js"></script>
    <script src="vec3.js"></script>
    <script src="mat4.js"></script>
    <script src="crtanje3DShader.js"></script>
    <script type="module">
      import GUI from "./gui_lib/muigui-0.x.module.js";

      let adapter;
      let device;

      let canvas;
      let context;
      let presentationFormat;

      let brojVrhovaPiramide;
      let uniformBuffer;
      let uniformViews;
      let testBuff;
      let testViews;

      let pipeline;
      let pyramid3DbindGroup;

      const settings = {
        fieldOfView: (100 * Math.PI) / 180,
        cameraAngle: 0,
      };
      let matrica3D;

      //ovo mora bit globalna varijabla
      let depthTexture;

      async function setUpWebGPU() {
        adapter = await navigator.gpu?.requestAdapter();
        device = await adapter?.requestDevice();
        if (!device) {
          fail("need a browser that supports WebGPU");
          return;
        }

        // Get a WebGPU context from the canvas and configure it
        canvas = document.querySelector("canvas");
        context = canvas.getContext("webgpu");
        presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device,
          format: presentationFormat,
          alphaMode: "premultiplied",
        });
      }

      function kreirajBuffere() {
        let uniformValues = new ArrayBuffer(64);
        uniformViews = {
          matrix: new Float32Array(uniformValues),
        };

        uniformBuffer = device.createBuffer({
          label: "uniforms",
          size: uniformValues.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        let { podaciKoordinata2, podaciBoja2, brojVrhova2 } =
          definirajPiramidu2();
        brojVrhovaPiramide = brojVrhova2;
        const testValues = new ArrayBuffer(544);
        let testViews = [];
        for (let i = 0; i < brojVrhova2; i++) {
          testViews.push({
            position: new Float32Array(testValues, 32 * i, 4),
            color: new Float32Array(testValues, 32 * i + 16, 4),
          });
          testViews[i].position.set([
            podaciKoordinata2[i * 4],
            podaciKoordinata2[i * 4 + 1],
            podaciKoordinata2[i * 4 + 2],
            podaciKoordinata2[i * 4 + 3],
          ]);
          testViews[i].color.set([
            podaciBoja2[i * 4],
            podaciBoja2[i * 4 + 1],
            podaciBoja2[i * 4 + 2],
            podaciBoja2[i * 4 + 3],
          ]);
        }

        testBuff = device.createBuffer({
          label: "default piramida buffer",
          size: testValues.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(testBuff, 0, testValues);
      }

      function kreirajPyramidRenderShader() {
        let crtanje3DModule = device.createShaderModule({
          code: crtanje3DShader,
        });

        pipeline = device.createRenderPipeline({
          label: "2 attributes",
          layout: "auto",
          vertex: {
            module: crtanje3DModule,
          },
          fragment: {
            module: crtanje3DModule,
            targets: [{ format: presentationFormat }],
          },
          primitive: {
            cullMode: "back",
          },
          depthStencil: {
            depthWriteEnabled: true,
            depthCompare: "less",
            format: "depth24plus",
          },
        });

        pyramid3DbindGroup = device.createBindGroup({
          label: "bind group for object",
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: uniformBuffer } },
            { binding: 1, resource: { buffer: testBuff } },
          ],
        });
      }

      function setUpGUI(render) {
        const radToDegOptions = {
          min: -360,
          max: 360,
          step: 1,
          converters: GUI.converters.radToDeg,
        };
        const gui = new GUI();
        gui.onChange(render);
        gui.add(settings, "fieldOfView", {
          min: 1,
          max: 179,
          converters: GUI.converters.radToDeg,
        });
        gui.add(settings, "cameraAngle", radToDegOptions);
      }

      function postaviMatricu3DTransformacija() {
        //??? zašto treba taj aspect i fieldofview, šta oni predstsavljaju na kraju (znear i zfar je easy)
        const aspect = canvas.clientWidth / canvas.clientHeight;
        const projection = mat4.perspektiva(
          settings.fieldOfView,
          aspect,
          1, // zNear
          2000 // zFar
        );

        //točka u koju gledamo s kamerom
        const fPosition = [0, 0, 0];
        //radijus kružnice na čijem rubu je kamera (kolko je kamera daleko od centra)
        const radius = 200;
        // Use matrix math to compute a position on a circle where
        // the camera is
        let tempMatrix = mat4.rotacijaY(settings.cameraAngle);
        mat4.translatiraj(tempMatrix, [0, 0, radius * 1.5], tempMatrix);

        // Get the camera's position from the matrix we computed
        const eye = tempMatrix.slice(12, 15);

        const up = [0, 1, 0];

        // Compute a view matrix

        const viewMatrix = mat4.pogledaj(eye, fPosition, up);

        // combine the view and projection matrixes
        const viewProjectionMatrix = mat4.mnozi(projection, viewMatrix);

        const angle = 0;
        const x = 0;
        const y = 0;
        const z = 0;

        return mat4.translatiraj(
          viewProjectionMatrix,
          [x, y, z],
          uniformViews.matrix
        );
      }

      function izvedi3DPiramidaRenderShader() {
        //---------------------------------
        //----- ENCODER ZA RENDERANJE -----
        //---------------------------------
        // Get the current texture from the canvas context and
        // set it as the texture to render to.
        const canvasTexture = context.getCurrentTexture();
        const renderPassDescriptor = {
          label: "our basic canvas renderPass",
          colorAttachments: [
            {
              // view: <- to be filled out when we render
              view: context.getCurrentTexture(),
              loadOp: "clear",
              storeOp: "store",
            },
          ],
          depthStencilAttachment: {
            // view: <- to be filled out when we render
            view: context.getCurrentTexture(),
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        };
        renderPassDescriptor.colorAttachments[0].view =
          canvasTexture.createView();

        // If we don't have a depth texture OR if its size is different
        // from the canvasTexture when make a new depth texture

        if (
          !depthTexture ||
          depthTexture.width !== canvasTexture.width ||
          depthTexture.height !== canvasTexture.height
        ) {
          if (depthTexture) {
            depthTexture.destroy();
          }
          depthTexture = device.createTexture({
            size: [canvasTexture.width, canvasTexture.height],
            format: "depth24plus",
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
          });
        }
        renderPassDescriptor.depthStencilAttachment.view =
          depthTexture.createView();

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass(renderPassDescriptor);
        pass.setPipeline(pipeline);

        device.queue.writeBuffer(uniformBuffer, 0, matrica3D);
        pass.setBindGroup(0, pyramid3DbindGroup);
        pass.draw(brojVrhovaPiramide, 10000);
        pass.end();
        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);
      }

      function render() {
        settings.cameraAngle += 0.005;
        matrica3D = postaviMatricu3DTransformacija();
        izvedi3DPiramidaRenderShader();
        requestAnimationFrame(render);
      }

      async function main() {
        await setUpWebGPU();
        kreirajBuffere();
        kreirajPyramidRenderShader();
        setUpGUI(render);

        //OVO TREBA OBRISAT
        const observer = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const canvas = entry.target;
            const width = entry.contentBoxSize[0].inlineSize;
            const height = entry.contentBoxSize[0].blockSize;
            canvas.width = Math.max(
              1,
              Math.min(width, device.limits.maxTextureDimension2D)
            );
            canvas.height = Math.max(
              1,
              Math.min(height, device.limits.maxTextureDimension2D)
            );
            // re-render
            render();
          }
        });
        observer.observe(canvas);
      }

      function fail(msg) {
        alert(msg);
      }

      main();
    </script>
  </head>
  <body>
    <canvas></canvas>
  </body>
</html>
