<!--SOURCE: https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Random Pixels</title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="" />
    <script src="prngComputeShaders.js"></script>
    <script src="particleRenderShaders.js"></script>
    <script>
      let adapter;
      let device;
      let canvas;

      let brojCestica = 256 * 10;
      let seeds = new Uint32Array([123456789, 362436069, 521288629, 88675123]);
      let xCoordBuffer;
      let yCoordBuffer;
      let zCoordBuffer;
      let seedsBuffer;
      let resultReadBuffer;

      let prngComputePipeline;
      let prngComputeBindGroup;

      let particleRenderPipeline;
      let particleRenderBindGroup;

      async function postaviWebGPU() {
        //UČITAVANJE KONTEKSTA I OSTALIH WEBGPU STVARI
        adapter = await navigator.gpu?.requestAdapter();
        /*
              const requiredLimits = {
                maxBufferSize: 2147483648,
                maxStorageBufferBindingSize: 2147483644,
                maxComputeInvocationsPerWorkgroup: 1024,
                maxComputeWorkgroupSizeX: 1024,maxComputeWorkgroupSizeY:1024
              };
              const device = await adapter?.requestDevice({
                requiredLimits,
              });
              */
        device = await adapter?.requestDevice();
        if (!device) {
          fail("Potreban je preglednik koji podržava WebGPU!");
          return;
        }

        canvas = document.getElementById("canvas");
        context = canvas.getContext("webgpu");
        context.configure({
          device: device,
          format: navigator.gpu.getPreferredCanvasFormat(),
          alphaMode: "premultiplied",
        });
      }
      function dodajRand() {
        return Math.random() * 10; //Math.random();
      }
      function kreirajBuffere() {
        //KREIRANJE BUFFERA

        //_____seed storage buffer_____
        seeds = new Uint32Array([
          seeds[0] * dodajRand(),
          seeds[1] * dodajRand(),
          seeds[2] * dodajRand(),
          seeds[3] * dodajRand(),
        ]);
        seedsBuffer = device.createBuffer({
          label: "seeds buffer",
          size: seeds.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(seedsBuffer, 0, seeds);

        //_____resultWrite storage buffer_____ (za pisanje unutar shadera u GPU)
        xCoordArray = new Float32Array(brojCestica);
        xCoordBuffer = device.createBuffer({
          label: "xKoordinate buffer",
          size: xCoordArray.byteLength,
          usage:
            GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
        });
        //device.queue.writeBuffer(resultWriteBuffer, 0, input);

        //_____resultWrite storage buffer_____ (za pisanje unutar shadera u GPU)
        yCoordArray = new Float32Array(brojCestica);
        yCoordBuffer = device.createBuffer({
          label: "yKoordinate buffer",
          size: yCoordArray.byteLength,
          usage:
            GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
        });
        //device.queue.writeBuffer(resultWriteBuffer, 0, input);

        //_____resultWrite storage buffer_____ (za pisanje unutar shadera u GPU)
        zCoordArray = new Float32Array(brojCestica);
        zCoordBuffer = device.createBuffer({
          label: "zKoordinate buffer",
          size: zCoordArray.byteLength,
          usage:
            GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
        });
        //device.queue.writeBuffer(resultWriteBuffer, 0, input);

        //_____resultRead storage buffer_____ (za čitanje iz shadera u GPU u Javascript)
        resultReadBuffer = device.createBuffer({
          label: "test buffer",
          size: xCoordArray.byteLength,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        });
      }

      function kreirajPRNGComputeShader() {
        //KOMPILACIJA --COMPUTE-- SHADERA
        const prngComputeModule = device.createShaderModule({
          label: "PRNG Compute Shader",
          code: prngComputeShaders,
        });

        device.pushErrorScope("validation");

        //IZRADA --COMPUTE-- PIPELINEA
        let prngComputePipelineDescriptor = {
          compute: {
            module: prngComputeModule,
            entryPoint: "popuniKoordinateCestica",
          },
          layout: "auto",
        };

        prngComputePipeline = device.createComputePipeline(
          prngComputePipelineDescriptor
        );

        //IZRADA --COMPUTE-- BIND GROUP-A
        prngComputeBindGroup = device.createBindGroup({
          layout: prngComputePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: { buffer: xCoordBuffer },
            },
            {
              binding: 1,
              resource: { buffer: yCoordBuffer },
            },
            {
              binding: 2,
              resource: { buffer: zCoordBuffer },
            },
            {
              binding: 3,
              resource: { buffer: seedsBuffer },
            },
          ],
        });
      }

      function kreirajParticleRednerShader() {
        //KOMPILACIJA -- PARTICLE RENDER-- SHADERA
        let particleRenderModule = device.createShaderModule({
          code: particleRenderShaders,
        });

        /*
            let error = await device.popErrorScope();
            if (error) {
              throw Error("Greška u render shader-u; pogledajte konzolu.");
            }
        */

        device.pushErrorScope("validation");

        //IZRADA --RENDER-- PIPELINEAd
        let renderPipelineDescriptor = {
          vertex: {
            module: particleRenderModule,
            entryPoint: "vertexMain",
          },
          fragment: {
            module: particleRenderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: navigator.gpu.getPreferredCanvasFormat(),
              },
            ],
          },
          primitive: {
            topology: "point-list",
          },
          layout: "auto",
        };

        particleRenderPipeline = device.createRenderPipeline(
          renderPipelineDescriptor
        );

        //IZRADA --REDNER-- BIND GROUP-A
        particleRenderBindGroup = device.createBindGroup({
          layout: particleRenderPipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: xCoordBuffer,
              },
            },
            {
              binding: 1,
              resource: {
                buffer: yCoordBuffer,
              },
            },
            {
              binding: 2,
              resource: {
                buffer: zCoordBuffer,
              },
            },
          ],
        });
      }

      function izvrsiPRNGComputeShader() {
        //IZRADA --COMPUTE-- ENCODERA
        const computeEncoder = device.createCommandEncoder({
          label: "PRNG encoder",
        });
        const computePass = computeEncoder.beginComputePass({
          label: "PRNG compute pass",
        });
        computePass.setPipeline(prngComputePipeline);
        computePass.setBindGroup(0, prngComputeBindGroup);
        computePass.dispatchWorkgroups(
          brojCestica / (brojCestica < 256 ? 1 : 256)
        );
        computePass.end();

        computeEncoder.copyBufferToBuffer(
          xCoordBuffer,
          0,
          resultReadBuffer,
          0,
          resultReadBuffer.size
        );
        const commandBuffer = computeEncoder.finish();
        device.queue.submit([commandBuffer]);
      }

      function izvrsiParticleRednerShader() {
        //IZRADA --RENDER-- ENCODERA
        let commandEncoder = device.createCommandEncoder();
        let renderPassDescriptor = {
          colorAttachments: [
            {
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              loadOp: "clear",
              storeOp: "store",
              view: context.getCurrentTexture().createView(),
            },
          ],
        };
        let passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(particleRenderPipeline);
        passEncoder.setBindGroup(0, particleRenderBindGroup);
        passEncoder.draw(brojCestica);
        passEncoder.end();
        device.queue.submit([commandEncoder.finish()]);
      }

      async function ispisRezultata() {
        //ČITANJE REZULTATA
        await resultReadBuffer.mapAsync(GPUMapMode.READ);
        const result = new Float32Array(
          resultReadBuffer.getMappedRange().slice()
        );

        console.log("SEEDS: ", seeds.toString());
        let f = result
          .map(function (num) {
            return num;
          })
          .sort();

        let projectionRange = 10;
        let z = [];
        for (let i = 0; i < projectionRange; i++) {
          z.push(0);
        }
        for (let i = 0; i < f.length; i++) {
          if (f[i] < -0.8) z[0] += 1;
          else if (f[i] < -0.6) z[1] += 1;
          else if (f[i] < -0.4) z[2] += 1;
          else if (f[i] < -0.2) z[3] += 1;
          else if (f[i] < 0) z[4] += 1;
          else if (f[i] < 0.2) z[5] += 1;
          else if (f[i] < 0.4) z[6] += 1;
          else if (f[i] < 0.6) z[7] += 1;
          else if (f[i] < 0.8) z[8] += 1;
          else z[9] += 1;
        }
        console.log(z);
        console.log(f.length);
        console.log(f.sort()[f.length - 1].toString());
      }

      function animacija() {
        seeds = new Uint32Array([
          seeds[0] * dodajRand(),
          seeds[1] * dodajRand(),
          seeds[2] * dodajRand(),
          seeds[3] * dodajRand(),
        ]);

        device.queue.writeBuffer(seedsBuffer, 0, seeds);

        izvrsiPRNGComputeShader();
        izvrsiParticleRednerShader();
        requestAnimationFrame(animacija);
      }

      async function main() {
        await postaviWebGPU();
        kreirajBuffere();
        kreirajPRNGComputeShader();
        kreirajParticleRednerShader();

        izvrsiPRNGComputeShader();
        izvrsiParticleRednerShader();

        //ispisRezultata();

        animacija();
      }

      function fail(msg) {
        // eslint-disable-next-line no-alert
        alert(msg);
      }

      main();
    </script>
  </head>
  <body>
    <canvas id="canvas" width="700" height="700"></canvas>
  </body>
</html>
