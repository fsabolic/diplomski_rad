<!DOCTYPE html>
<html>
  <body>
    <script type="module">
      const computeShaderWGSL = `
            struct Tocka {
              pozicija: vec2<f32>,
            }

            @group(0) @binding(0) var<storage, read_write> tocke: array<Tocka>;
            @group(0) @binding(1) var<uniform> vrijeme: f32;

            @compute @workgroup_size(64)
            fn generirajTocke(@builtin(global_invocation_id) global_id: vec3<u32>) {
              let index = global_id.x;
              if (index >= arrayLength(&tocke)) {
                return;
              }
              let x = f32(index) / f32(arrayLength(&tocke)) * 2.0 * 3.14159;
              let y = sin(x + vrijeme);
              tocke[index].pozicija = vec2<f32>(x / 3.14159 - 1.0, y * 0.5);
            }
          `;

      const vertexShaderWGSL = `
            struct VrhOutput {
              @builtin(position) pozicija: vec4<f32>,
              @location(0) boja: vec4<f32>,
            }

            @vertex
            fn postaviVrhove(@location(0) pozicija: vec2<f32>) -> VrhOutput {
              var out: VrhOutput;
              out.pozicija = vec4<f32>(pozicija, 0.0, 1.0);
              out.boja = vec4<f32>(pozicija.x + 1.0, pozicija.y + 0.5, 0.5, 1.0);
              return out;
            }
          `;
      const fragmentShaderWGSL = `
            @fragment
            fn postaviBoju(@location(0) boja: vec4<f32>) -> @location(0) vec4<f32> {
              return boja;
            }
          `;
      async function initWebGPU() {
        const canvas = document.getElementById("container");
        const context = canvas.getContext("webgpu");
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();

        context.configure({
          device: device,
          format: "bgra8unorm",
          alphaMode: "premultiplied",
        });

        const brTocaka = 256 * 10;

        const tockeVertexStorageBuff = device.createBuffer({
          size: brTocaka * 8,
          usage:
            GPUBufferUsage.STORAGE |
            GPUBufferUsage.VERTEX |
            GPUBufferUsage.COPY_DST,
        });

        const vrijemeUnifBuff = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const computeShaderModule = device.createShaderModule({
          code: computeShaderWGSL,
        });

        const vertexShaderModule = device.createShaderModule({
          code: vertexShaderWGSL,
        });

        const fragmentShaderModule = device.createShaderModule({
          code: fragmentShaderWGSL,
        });

        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.COMPUTE,
              buffer: { type: "storage" },
            },
            {
              binding: 1,
              visibility: GPUShaderStage.COMPUTE,
              buffer: { type: "uniform" },
            },
          ],
        });

        const bindGroup = device.createBindGroup({
          layout: bindGroupLayout,
          entries: [
            { binding: 0, resource: { buffer: tockeVertexStorageBuff } },
            { binding: 1, resource: { buffer: vrijemeUnifBuff } },
          ],
        });

        const computePipeline = device.createComputePipeline({
          layout: device.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout],
          }),
          compute: {
            module: computeShaderModule,
            entryPoint: "generirajTocke",
          },
        });

        const renderPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: vertexShaderModule,
            entryPoint: "postaviVrhove",
            buffers: [
              {
                arrayStride: 8,
                attributes: [
                  { shaderLocation: 0, format: "float32x2", offset: 0 },
                ],
              },
            ],
          },
          fragment: {
            module: fragmentShaderModule,
            entryPoint: "postaviBoju",
            targets: [{ format: "bgra8unorm" }],
          },
          primitive: { topology: "point-list" },
        });

        let i = 0;
        function slicica() {
          const vrijeme = i++ / 125;
          device.queue.writeBuffer(
            vrijemeUnifBuff,
            0,
            new Float32Array([vrijeme])
          );

          const commandEncoder = device.createCommandEncoder();

          const computePass = commandEncoder.beginComputePass();
          computePass.setPipeline(computePipeline);
          computePass.setBindGroup(0, bindGroup);
          computePass.dispatchWorkgroups(Math.ceil(brTocaka / 64));
          computePass.end();

          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: context.getCurrentTexture().createView(),
                loadOp: "clear",
                storeOp: "store",
                clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
              },
            ],
          });
          renderPass.setPipeline(renderPipeline);
          renderPass.setVertexBuffer(0, tockeVertexStorageBuff);
          renderPass.draw(brTocaka);
          renderPass.end();

          device.queue.submit([commandEncoder.finish()]);
          requestAnimationFrame(slicica);
        }

        requestAnimationFrame(slicica);
      }

      initWebGPU();
    </script>

    <canvas id="container" width="600" height="600"></canvas>
  </body>
</html>
